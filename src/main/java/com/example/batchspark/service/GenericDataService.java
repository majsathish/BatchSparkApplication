package com.example.batchspark.service;

import com.example.batchspark.model.ColumnConfig;
import com.example.batchspark.model.FileConfig;
import com.example.batchspark.model.GenericDataRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class GenericDataService {
    
    private static final Logger log = LoggerFactory.getLogger(GenericDataService.class);
    
    private final JdbcTemplate jdbcTemplate;
    
    public GenericDataService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    @Transactional
    public void createTableIfNotExists(FileConfig fileConfig) {
        String tableName = fileConfig.getTargetTableName();
        
        // Check if table exists
        String checkTableSql = "SELECT COUNT(*) FROM user_tables WHERE table_name = ?";
        Integer count = jdbcTemplate.queryForObject(checkTableSql, Integer.class, tableName.toUpperCase());
        
        if (count == 0) {
            // Create table
            StringBuilder createTableSql = new StringBuilder();
            createTableSql.append("CREATE TABLE ").append(tableName).append(" (");
            createTableSql.append("ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, ");
            
            for (ColumnConfig column : fileConfig.getColumnConfigs()) {
                createTableSql.append(column.getTargetColumnName()).append(" ");
                createTableSql.append(getOracleDataType(column));
                
                if (!column.getIsNullable()) {
                    createTableSql.append(" NOT NULL");
                }
                
                createTableSql.append(", ");
            }
            
            createTableSql.append("CREATED_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ");
            createTableSql.append("UPDATED_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP");
            createTableSql.append(")");
            
            log.info("Creating table: {}", createTableSql.toString());
            jdbcTemplate.execute(createTableSql.toString());
        }
    }
    
    @Transactional
    public void insertBatch(List<GenericDataRecord> records, FileConfig fileConfig) {
        if (records.isEmpty()) {
            return;
        }
        
        String tableName = fileConfig.getTargetTableName();
        List<ColumnConfig> columns = fileConfig.getColumnConfigs();
        
        // Build insert SQL
        StringBuilder insertSql = new StringBuilder();
        insertSql.append("INSERT INTO ").append(tableName).append(" (");
        
        String columnNames = columns.stream()
                .map(ColumnConfig::getTargetColumnName)
                .collect(Collectors.joining(", "));
        
        insertSql.append(columnNames).append(") VALUES (");
        
        String placeholders = columns.stream()
                .map(c -> "?")
                .collect(Collectors.joining(", "));
        
        insertSql.append(placeholders).append(")");
        
        // Prepare batch data
        List<Object[]> batchArgs = records.stream()
                .map(record -> columns.stream()
                        .map(column -> convertValue(
                                record.getColumnValue(column.getSourceColumnName()),
                                column.getDataType()))
                        .toArray())
                .collect(Collectors.toList());
        
        log.info("Executing batch insert for {} records into table {}", records.size(), tableName);
        jdbcTemplate.batchUpdate(insertSql.toString(), batchArgs);
    }
    
    private String getOracleDataType(ColumnConfig column) {
        String dataType = column.getDataType().toUpperCase();
        
        switch (dataType) {
            case "VARCHAR2":
            case "STRING":
                return "VARCHAR2(" + (column.getMaxLength() != null ? column.getMaxLength() : 255) + ")";
            case "NUMBER":
            case "DECIMAL":
            case "BIGDECIMAL":
                return "NUMBER(19,2)";
            case "INTEGER":
            case "INT":
                return "NUMBER(10)";
            case "LONG":
                return "NUMBER(19)";
            case "DATE":
                return "DATE";
            case "TIMESTAMP":
            case "DATETIME":
                return "TIMESTAMP";
            case "BOOLEAN":
                return "NUMBER(1)";
            default:
                return "VARCHAR2(255)";
        }
    }
    
    private Object convertValue(Object value, String dataType) {
        if (value == null || value.toString().trim().isEmpty()) {
            return null;
        }
        
        String stringValue = value.toString().trim();
        
        try {
            switch (dataType.toUpperCase()) {
                case "NUMBER":
                case "DECIMAL":
                case "BIGDECIMAL":
                    return new BigDecimal(stringValue);
                case "INTEGER":
                case "INT":
                    return Integer.valueOf(stringValue);
                case "LONG":
                    return Long.valueOf(stringValue);
                case "DATE":
                    return Date.valueOf(LocalDate.parse(stringValue, DateTimeFormatter.ISO_LOCAL_DATE));
                case "TIMESTAMP":
                case "DATETIME":
                    return Timestamp.valueOf(LocalDateTime.parse(stringValue, DateTimeFormatter.ISO_LOCAL_DATE_TIME));
                case "BOOLEAN":
                    return Boolean.valueOf(stringValue) ? 1 : 0;
                default:
                    return stringValue;
            }
        } catch (Exception e) {
            log.warn("Error converting value '{}' to type '{}': {}", stringValue, dataType, e.getMessage());
            return stringValue; // Return as string if conversion fails
        }
    }
}